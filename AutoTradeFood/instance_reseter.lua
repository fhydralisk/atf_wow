---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by hydra.
--- DateTime: 2020-01-17 23:01
---

local addonName, L = ...

local frame = CreateFrame("FRAME", "ATFFrame")
frame:RegisterEvent("CHAT_MSG_SYSTEM")
frame:RegisterEvent("CHAT_MSG_ADDON")
frame:RegisterEvent("ADDON_LOADED")

SLASH_REMOVE_BLACKLIST1 = "/atrrbl"

local timeout = L.reset_instance_timeout


local reseter_context = {
    player=nil,
    class=nil,
    request_ts=nil,
    invite_ts=nil,
    reset=nil,
    frontend=nil,
    instance=nil,
    queue_length=nil,
    lb_sender=nil,
}

local last_ctx = {}

local just_started = true

local block_intention_list = {}
local block_duration_to_block = 120
local block_duration_try_block = 0
local block_duration_repeat_request = 3600


local function can_reset(player)
    return UnitInParty(player) and not UnitIsConnected(player) and reseter_context.invite_ts and GetTime() - reseter_context.invite_ts > 2
end


local function dequeue_reseter()
    if #InstanceResetQueue > 0 then
        local queued = InstanceResetQueue[1]
        table.remove(InstanceResetQueue, 1)
        return queued
    end
end


local function notify_queued_player()
    for i, q in ipairs(InstanceResetQueue) do
        L.F.whisper_or_say("重置队列已更新，您的当前位置："..i, q.player)
    end
end


local function get_block_duration(player)
    if ATFResetBlockList[player] then
        local deadline = ATFResetBlockList[player].deadline
        if deadline == 0 then
            return 0
        elseif deadline > GetTime() then
            return deadline - GetTime()
        else
            ATFResetBlockList[player] = nil
        end
    end
end


local function block_player(player, duration)
    if duration == 0 then
        ATFResetBlockList[player] = { deadline=0 }
    else
        ATFResetBlockList[player] = { deadline=GetTime() + duration }
    end
end


local function block_intention(player, duration)
    if not block_intention_list[date("%x")] then
        block_intention_list[date("%x")] = {}
    end
    if not block_intention_list[date("%x")][player] then
        block_intention_list[date("%x")][player] = 0
    end

    block_intention_list[date("%x")][player] = block_intention_list[date("%x")][player] + duration
    local block_reset_duration = block_intention_list[date("%x")][player]
    if block_reset_duration >= block_duration_to_block then
        block_player(player, block_duration_try_block)
        block_intention_list[date("%x")][player] = nil
    end
    return math.max(math.modf(block_duration_to_block - block_reset_duration), 0)
end


local function detect_block_intention()
    if reseter_context.request_ts then
        local block_reset_duration = GetTime() - reseter_context.request_ts
        if block_reset_duration >= 20 then
            local block_remain = block_intention(reseter_context.player, block_reset_duration)
            L.F.whisper_or_say("【敬告】不当的使用重置功能，导致阻塞重置队列的玩家，将被禁止使用该功能。", reseter_context.player)
            if block_remain > 0 then
                L.F.whisper_or_say("本次重置您阻塞了重置队列"..math.modf(block_reset_duration).."秒，若再次累计阻塞"..block_remain.."秒，您将被禁止使用该功能。", reseter_context.player)
                L.F.whisper_or_say("为防止被禁用，烦请您快速接受组队邀请，并迅速通过/camp宏或返回人物选择按键下线，谢谢合作。", reseter_context.player)
            else
                L.F.whisper_or_say("由于您多次阻塞重置队列，累计阻塞时长达到警戒值，您已被限制/禁止使用该功能。", reseter_context.player)
            end
        end
    end
end


function L.F.drive_reset_instance()
    if just_started then
        just_started = false
        if #InstanceResetQueue > 0 then
            print("queue is not empty")
            for _, q in ipairs(InstanceResetQueue) do
                SendChatMessage("十分抱歉，重置工具人刚刚被服务器踢下线，所有重置请求已取消，请您重新请求。", "WHISPER", nil, q.player)
            end
        end
        InstanceResetQueue = {}
        if UnitInParty("player") then
            local player = UnitName("party1")
            if UnitIsGroupLeader("player") then
                if UnitIsConnected("party1") then
                    L.F.whisper_or_say("由于工具人刚刚从掉线中恢复，本次重置失败，请您再次尝试下线，或离队后重新请求，十分抱歉！", player)
                    reseter_context = {
                        player=player,
                        request_ts=GetTime(),
                        invite_ts=GetTime(),
                        class=UnitClass("party1"),
                        frontend=nil,
                    }
                    last_ctx = reseter_context
                else
                    ResetInstances()
                    LeaveParty()
                end
            else
                L.F.whisper_or_say("由于工具人刚刚从掉线中恢复，本次重置失败，请您重新请求，十分抱歉！", player)
                LeaveParty()
            end
            return
        end
    end

    local player = reseter_context.player
    if player then
        if GetTime() - reseter_context.request_ts > timeout then
            L.F.whisper_or_say("未能重置，您未在规定时间内下线。", player)
            LeaveParty()
            detect_block_intention()
            reseter_context = {}
        elseif reseter_context.reset then
            reseter_context = {}
            UninviteUnit(player)
        elseif can_reset(player) then
            print("reseting")
            ResetInstances()
            print("reseted")
            reseter_context.reset = true
            if reseter_context.frontend then
                --SendChatMessage("米豪已帮【"..player.."】重置副本。请M "..reseter_context.frontend.." 【"..L.cmds.reset_instance_help.."】查看使用方法。", "say")
            else
                --SendChatMessage("米豪已帮【"..player.."】重置副本。请M{player}【"..L.cmds.reset_instance_help.."】查看使用方法。", "say")
            end
        end
    else
        local queued = dequeue_reseter()
        if queued then
            player = queued.player
            last_ctx = reseter_context
            reseter_context.player = player
            reseter_context.request_ts = GetTime()
            reseter_context.frontend = queued.frontend
            reseter_context.lb_sender = queued.lb_sender
            LeaveParty()
            InviteUnit(player)
            L.F.whisper_or_say("请接受组队邀请，然后立即下线。请求有效期"..timeout.."秒。", player)
            notify_queued_player()
        end
    end
end


local function pre_enqueue_player(player)
    for i, q_player in ipairs(InstanceResetQueue) do
        if q_player.player == player then
            q_player.request_count = q_player.request_count + 1
            if q_player.request_count > 10 then
                L.F.whisper_or_say("由于您过于频繁的请求，您已被暂停使用该服务。您已被移出队列。", player)
                table.remove(InstanceResetQueue, i)
                block_player(player, block_duration_repeat_request)
                return false
            else
                L.F.whisper_or_say("您已在队列中，队列位置："..i.."。请勿重复请求，刷屏可能会被暂停使用该功能，谢谢！", player)
                return false
            end
        end
    end

    return true
end


local function enqueue_player(player, frontend, lb_sender)
    table.insert(InstanceResetQueue, { player=player, request_ts=GetTime(), request_count=1, frontend=frontend, lb_sender=lb_sender})
    return #InstanceResetQueue
end


local function try_load_balance(player, queue_size)
    if #ATFClientSettings.reset_lb > 0 then
        local lb_player = ATFClientSettings.reset_lb[math.random(1, #ATFClientSettings.reset_lb)]
        C_ChatInfo.SendAddonMessage('ATF', "load_balance:"..player..","..queue_size, "whisper", lb_player)
    end
end


local function ack_load_balance(player, sender)
    local pos = enqueue_player(player, nil, sender)
    local msg = "load_balance_ack:"..player
    C_ChatInfo.SendAddonMessage('ATF', msg, "whisper", sender)
    print("ack to "..sender.." "..msg)
    L.F.whisper_or_say("为提高您的体验，已为您调度至新重置工具人队列。", player)
    if pos > 0 then
        L.F.whisper_or_say("队列位置："..pos, player)
    end
end


local function check_and_ack_load_balance(player, sender, queue_size)
    if #InstanceResetQueue < queue_size then
        ack_load_balance(player, sender)
    end
end


local function remove_player_in_queue(player)
    local pos

    for i, q_player in ipairs(InstanceResetQueue) do
        if q_player.player == player then
            pos = i
            break
        end
    end

    if pos then
        table.remove(InstanceResetQueue, pos)
    end
end


function L.F.reset_instance_request_frontend(player)
    local backend = L.F.choice_random_backend()

    if backend then
        C_ChatInfo.SendAddonMessage("ATF", "reset:"..player, "WHISPER", backend)
        L.F.whisper_or_say("重置请求已转发至重置后端【"..backend.."】，请等待其回应。", player)
    else
        L.F.whisper_or_say("重置服务离线，待重置后端账号上线后可用。", player)
    end
end


function L.F.reset_instance_request(player, frontend)
    if ATFClientSettings.lb_only then
        L.F.whisper_or_say("该重置侠仅为高峰分担负载使用，请M我的主号 - 米豪重置侠: 重置，谢谢", player)
        return
    end
    if not (L.F.watch_dog_ok()) then
        L.F.whisper_or_say(
                "米豪的驱动程序出现故障，重置副本功能暂时失效，请等待米豪的维修师进行修复。十分抱歉！", player)
        return
    end
    assert(L.F.is_backend())

    local block_duration = get_block_duration(player)

    if block_duration then
        if block_duration > 0 then
            L.F.whisper_or_say("由于刷屏或其他原因，您已被暂停该服务【"..math.ceil(block_duration / 60).."】分钟。请解禁后避免刷屏操作，谢谢合作！", player)
        else
            L.F.whisper_or_say("由于您的不当使用，该服务已向您永久关闭，请邮件联系【米豪】咨询解禁事宜，抱歉！", player)
        end
        return
    end

    pcall(L.F.say_boom_predict, player)

    if UnitInParty(player) then
        if reseter_context.player == player then
            L.F.whisper_or_say("【重置流程变更】当前版本只需在【未进组】的情况下M{player}一次请求即可。无需再次请求。", player)
        else
            L.F.whisper_or_say("【重置流程变更】为避免高峰期重置冲突，重置流程发生变化，您务必在【未进组】的前提下想{player}发起请求。本次请求失败。", player)
        end
        return
    elseif reseter_context.player == player then
        L.F.whisper_or_say("请接受组队邀请，然后立即下线。", player)
        return
    end
    if not pre_enqueue_player(player) then
        return
    end
    local queue_pos = enqueue_player(player, frontend)
    if queue_pos > 1 or (queue_pos == 1 and reseter_context.player) then
        L.F.whisper_or_say("目前正在为其他玩家重置，已为您排队。请勿重复请求，刷屏可能会被暂停服务，谢谢支持！", player)
        L.F.whisper_or_say("队列位置："..queue_pos, player)
    end

    if queue_pos >= (ATFClientSettings.lb_queue_size or 3) then
        try_load_balance(player, queue_pos)
    end
end


function L.F.say_reset_instance_help(to_player)
    L.F.whisper_or_say("重置副本功能可以帮您迅速传送至副本门口，并对副本内怪物进行重置。请按如下步骤操作", to_player)
    L.F.whisper_or_say("1. 请确保您不在队伍中，且副本内没有其他玩家，然后M{player}【"..L.cmds.reset_instance_cmd.."】", to_player)
    L.F.whisper_or_say("2. 如果请求成功，{player}的【重置工具人】会向您发起组队邀请。请您进入队伍后在"..timeout.."秒内下线。", to_player)
    L.F.whisper_or_say("3. 一旦您下线，{player}会立即重置副本。", to_player)
    L.F.whisper_or_say("4. 如果您未爆本，下次上线您将会出现在副本门口，且副本内怪物已重置。", to_player)
    L.F.whisper_or_say("注：如果下次上线您发现在炉石点，说明：您已爆本或服务器总副本数量达到上限。", to_player)
end


local function record_instance_reset(player, instance)
    local irs
    if InstanceResetRecord[player] then
        irs = InstanceResetRecord[player]
    else
        irs = {}
    end
    InstanceResetRecord[player] = {}
    local cts = math.modf(time())
    for _, ir in ipairs(irs) do
        if cts - ir.ts < 3600 then
            table.insert(InstanceResetRecord[player], ir)
        end
    end
    table.insert(InstanceResetRecord[player], {ts=cts, instance=instance})
end


function L.F.reset_instance_manual(player)
    record_instance_reset(player, "Manual")
    L.F.whisper_or_say("【爆本预警】{player}已为您记录此次重置时间。请M{player}【"..L.cmds.boom_predict.."】查看爆本情况。", player)
end


function L.F.bind_reseter_backend()
    SetBinding(L.hotkeys.interact_key, "SITORSTAND")
end


local function statistics_reset_instance(reset_ctx)
    local name = reset_ctx.player
    local class = reset_ctx.class
    local instance = reset_ctx.instance
    local key_instance_ind = "reset.ind."..date("%x").."."..name
    local key_instance_class = "reset.class."..date("%x").."."..class
    local key_instance_instance = "reset.instance."..date("%x").."."..instance
    local key_instance_count = "reset.count."..date("%x")
    L.F.merge_statistics_plus_int(key_instance_ind, 1)
    L.F.merge_statistics_plus_int(key_instance_class, 1)
    L.F.merge_statistics_plus_int(key_instance_instance, 1)
    L.F.merge_statistics_plus_int(key_instance_count, 1)
    if reset_ctx.lb_sender == nil then
        record_instance_reset(name, instance)
    end
end


local function boom_predict(player)
    if InstanceResetRecord[player] then
        local cnt = 0
        local cts = math.modf(time())
        local ts_in_1h = cts - 3600
        for _, ir in ipairs(InstanceResetRecord[player]) do
            if cts - ir.ts < 3600 then
                cnt = cnt + 1
                if ts_in_1h <= cts - 3600 then
                    ts_in_1h = ir.ts
                end
            end
        end
        return math.max(0, 5 - cnt), 3600 - cts + ts_in_1h
    else
        return 5, 0
    end
end


function L.F.say_boom_predict(to_player)
    local remain, unlock_dur = boom_predict(to_player)
    if ATFClientSettings.lb_only then
        L.F.whisper_or_say("本工具人仅供负载均衡使用，查询爆本情况，请M 米豪重置侠：爆本", to_player)
        return
    end
    L.F.whisper_or_say("【爆本预警（测试版）】如果您一直使用米豪服务重置，{player}会尝试推测您的爆本情况，数据仅供参考。M{player}的重置工具人【"..L.cmds.boom_predict.."】可以获取该信息。", to_player)
    if remain == 1 then
        L.F.whisper_or_say("【爆本预警：危险】您当前时段的下次重置副本可能导致爆本。若执行重置，您可能会被传送回炉石点。", to_player)
        L.F.whisper_or_say("【爆本预警：危险】预计爆本封印将于"..math.modf(unlock_dur / 60).."分钟后解除。", to_player)
    elseif remain == 0 then
        L.F.whisper_or_say("【爆本预警：爆本】您已爆本，无法进入副本。预计爆本封印将于"..math.modf(unlock_dur / 60).."分钟后解除。", to_player)
    else
        L.F.whisper_or_say("【爆本预警：安全】您目前时间段可以重置副本而不爆本的剩余次数为【"..(remain - 1).."】次", to_player)
    end
end


local function may_record_success(message)
    local pattern = string.format(INSTANCE_RESET_SUCCESS, "(.+)")
    local instance = string.match(message, pattern)
    if instance then
        last_ctx.instance = instance
        last_ctx.queue_length = #InstanceResetQueue
        statistics_reset_instance(last_ctx)
        return true
    end
end


local function eventHandler(self, event, arg1, arg2, arg3, arg4)
    if event == "ADDON_LOADED" and arg1 == addonName then
        if ATFResetBlockList == nil then
            ATFResetBlockList = {}
        end
        if InstanceResetQueue == nil then
            InstanceResetQueue = {}
        end
        if InstanceResetRecord == nil then
            InstanceResetRecord = {}
        end
        return
    end
    if not(L.atfr_run) then
        return
    end

    if event == 'CHAT_MSG_SYSTEM' then
        local message = arg1
        if reseter_context.player then
            if string.format(ERR_DECLINE_GROUP_S, reseter_context.player) == message
                    or string.format(ERR_ALREADY_IN_GROUP_S, reseter_context.player) == message then
                L.F.whisper_or_say("您拒绝了组队邀请，重置请求已取消。", reseter_context.player)
                detect_block_intention()
                reseter_context = {}
            elseif string.format(ERR_JOINED_GROUP_S, reseter_context.player) == message
                    or string.format(ERR_RAID_MEMBER_ADDED_S, reseter_context.player) == message then
                L.F.whisper_or_say("请抓紧时间下线，{player}将在您下线后立即重置副本。", reseter_context.player)
                reseter_context.invite_ts = GetTime()
                reseter_context.class = UnitClass(reseter_context.player)
            elseif string.format(ERR_LEFT_GROUP_S, reseter_context.player) == message
                    or string.format(ERR_RAID_MEMBER_REMOVED_S, reseter_context.player) == message
                    or ERR_GROUP_DISBANDED == message then
                L.F.whisper_or_say("您离开了队伍，重置请求已取消。", reseter_context.player)
                detect_block_intention()
                reseter_context = {}
            elseif string.format(ERR_BAD_PLAYER_NAME_S, reseter_context.player) == message then
                reseter_context = {}
            elseif may_record_success(message) then
                -- do nothing
                L.F.whisper_or_say("已帮["..last_ctx.player.."]重置["..last_ctx.instance.."]，需要重置服务，请M我【"..L.cmds.help_cmd.."】")
                if last_ctx.lb_sender then
                    C_ChatInfo.SendAddonMessage(
                        "ATF",
                        "load_balance_reset_success:"..last_ctx.player..","..last_ctx.instance,
                        "whisper",
                        last_ctx.lb_sender
                    )
                end
            end
        end
    elseif event == "CHAT_MSG_ADDON" and arg1 == "ATF" then
        local message, author = arg2, arg4
        author = string.match(author, "([^-]+)")
        if L.F.is_frontend() then
            -- frontend do not respond to commands.
        else
            local cmd, target = string.match(message, "(.-):(.+)")
            if cmd and target then
                if cmd == "reset" then
                    author = string.match(author, "([^-]+)") or author
                    L.F.reset_instance_request(target, author)
                elseif cmd == "load_balance" then
                    local player, queue_size = string.match(target, "(.-),(.+)")
                    queue_size = tonumber(queue_size)
                    check_and_ack_load_balance(player, author, queue_size)

                elseif cmd == "load_balance_ack" then
                    print("removing player in reset queue"..target)
                    remove_player_in_queue(target)
                elseif cmd == "load_balance_reset_success" then
                    local player, instance = string.match(target, "(.-),(.+)")
                    print("record instance reset via lb")
                    record_instance_reset(player, instance)
                end
            end
        end
    end
end

frame:SetScript("OnEvent", eventHandler)


function SlashCmdList.REMOVE_BLACKLIST(msg)
    ATFResetBlockList[msg] = nil
    print(msg.." removed")
end
